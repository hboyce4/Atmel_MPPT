
#include "glcd_library_1_0.h"


uint8_t glcd_x, glcd_y;                    // Coordinates used to specify where the next text will go
uint8_t glcd_size;                         // Same for size
bool glcd_colour;                        // Same for colour


void glcd_setxy(uint8_t x, uint8_t y,uint8_t sz, bool cl) {
	glcd_x = x;
	glcd_y = y;            // set the coordinates
	glcd_size = sz;
	glcd_colour = cl;  // set the other factors
}


const uint8_t PROGMEM TEXT_3x6_1[0x41][3] ={0x00,0x00,0x00, // Space   0x20
	0x00,0x5C,0x00, // !
	0x0C,0x00,0x0C, // "
	0x7C,0x28,0x7C, // #
	0x7C,0x44,0x7C, // 0x
	0x24,0x10,0x48, // %
	0x28,0x54,0x08, // &
	0x00,0x0C,0x00, // '
	0x38,0x44,0x00, // (
	0x44,0x38,0x00, // )
	0x20,0x10,0x08, // //
	0x10,0x38,0x10, // +
	0x80,0x40,0x00, // ,
	0x10,0x10,0x10, // -
	0x00,0x40,0x00, // .
	0x20,0x10,0x08, // /
	0x38,0x44,0x38, // 0    0x30
	0x00,0x7C,0x00, // 1
	0x64,0x54,0x48, // 2
	0x44,0x54,0x28, // 3
	0x1C,0x10,0x7C, // 4
	0x4C,0x54,0x24, // 5
	0x38,0x54,0x20, // 6
	0x04,0x74,0x0C, // 7
	0x28,0x54,0x28, // 8
	0x08,0x54,0x38, // 9
	0x00,0x50,0x00, // :
	0x80,0x50,0x00, // ;
	0x10,0x28,0x44, // <
	0x28,0x28,0x28, // =
	0x44,0x28,0x10, // >
	0x04,0x54,0x08, // ?
	0x38,0x4C,0x5C, // @    0x40
	0x78,0x14,0x78, // A
	0x7C,0x54,0x28, // B
	0x38,0x44,0x44, // C
	0x7C,0x44,0x38, // D
	0x7C,0x54,0x44, // E
	0x7C,0x14,0x04, // F
	0x38,0x44,0x34, // G
	0x7C,0x10,0x7C, // H
	0x00,0x7C,0x00, // I
	0x20,0x40,0x3C, // J
	0x7C,0x10,0x6C, // K
	0x7C,0x40,0x40, // L
	0x7C,0x08,0x7C, // M
	0x7C,0x04,0x7C, // N
	0x7C,0x44,0x7C, // O
	0x7C,0x14,0x08, // P    0x50
	0x38,0x44,0x78, // Q
	0x7C,0x14,0x68, // R
	0x48,0x54,0x24, // S
	0x04,0x7C,0x04, // T
	0x7C,0x40,0x7C, // U
	0x3C,0x40,0x3C, // V
	0x7C,0x20,0x7C, // W
	0x6C,0x10,0x6C, // X
	0x1C,0x60,0x1C, // Y
	0x64,0x54,0x4C, // Z
	0x7C,0x44,0x00, // [
	0x08,0x10,0x20, // 
	0x44,0x7C,0x00, // ]
	0x08,0x04,0x08, // ^
	0x80,0x80,0x80, // _
	0x04,0x08,0x00 // ` 0x60
};


const uint8_t PROGMEM TEXT_5x7_1[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE
	0x00, 0x00, 0x5F, 0x00, 0x00, // !
	0x00, 0x03, 0x00, 0x03, 0x00, // "
	0x14, 0x3E, 0x14, 0x3E, 0x14, // #
	0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
	0x43, 0x33, 0x08, 0x66, 0x61, // %
	0x36, 0x49, 0x55, 0x22, 0x50, // &
	0x00, 0x05, 0x03, 0x00, 0x00, // '
	0x00, 0x1C, 0x22, 0x41, 0x00, // (
	0x00, 0x41, 0x22, 0x1C, 0x00, // )
	0x14, 0x08, 0x3E, 0x08, 0x14, // *
	0x08, 0x08, 0x3E, 0x08, 0x08, // +
	0x00, 0x50, 0x30, 0x00, 0x00, // ,
	0x08, 0x08, 0x08, 0x08, 0x08, // -
	0x00, 0x60, 0x60, 0x00, 0x00, // .
	0x20, 0x10, 0x08, 0x04, 0x02, // /
	0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
	0x04, 0x02, 0x7F, 0x00, 0x00, // 1
	0x42, 0x61, 0x51, 0x49, 0x46, // 2
	0x22, 0x41, 0x49, 0x49, 0x36, // 3
	0x18, 0x14, 0x12, 0x7F, 0x10, // 4
	0x27, 0x45, 0x45, 0x45, 0x39, // 5
	0x3E, 0x49, 0x49, 0x49, 0x32, // 6
	0x01, 0x01, 0x71, 0x09, 0x07, // 7
	0x36, 0x49, 0x49, 0x49, 0x36, // 8
	0x26, 0x49, 0x49, 0x49, 0x3E, // 9
	0x00, 0x36, 0x36, 0x00, 0x00, // :
	0x00, 0x56, 0x36, 0x00, 0x00, // ;
	0x08, 0x14, 0x22, 0x41, 0x00, // <
	0x14, 0x14, 0x14, 0x14, 0x14, // =
	0x00, 0x41, 0x22, 0x14, 0x08, // >
	0x02, 0x01, 0x51, 0x09, 0x06, // ?
	0x3E, 0x41, 0x59, 0x55, 0x5E, // @
	0x7E, 0x09, 0x09, 0x09, 0x7E, // A
	0x7F, 0x49, 0x49, 0x49, 0x36, // B
	0x3E, 0x41, 0x41, 0x41, 0x22, // C
	0x7F, 0x41, 0x41, 0x41, 0x3E, // D
	0x7F, 0x49, 0x49, 0x49, 0x41, // E
	0x7F, 0x09, 0x09, 0x09, 0x01, // F
	0x3E, 0x41, 0x41, 0x49, 0x3A, // G
	0x7F, 0x08, 0x08, 0x08, 0x7F, // H
	0x00, 0x41, 0x7F, 0x41, 0x00, // I
	0x30, 0x40, 0x40, 0x40, 0x3F, // J
	0x7F, 0x08, 0x14, 0x22, 0x41, // K
	0x7F, 0x40, 0x40, 0x40, 0x40, // L
	0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
	0x7F, 0x02, 0x04, 0x08, 0x7F, // N
	0x3E, 0x41, 0x41, 0x41, 0x3E, // O
	0x7F, 0x09, 0x09, 0x09, 0x06, // P
	0x1E, 0x21, 0x21, 0x21, 0x5E, // Q
0x7F, 0x09, 0x09, 0x09, 0x76};// R

const uint8_t PROGMEM TEXT_5x7_2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S
	0x01, 0x01, 0x7F, 0x01, 0x01, // T
	0x3F, 0x40, 0x40, 0x40, 0x3F, // U
	0x1F, 0x20, 0x40, 0x20, 0x1F, // V
	0x7F, 0x20, 0x10, 0x20, 0x7F, // W
	0x41, 0x22, 0x1C, 0x22, 0x41, // X
	0x07, 0x08, 0x70, 0x08, 0x07, // Y
	0x61, 0x51, 0x49, 0x45, 0x43, // Z
	0x00, 0x7F, 0x41, 0x00, 0x00, // [
	0x02, 0x04, 0x08, 0x10, 0x20, // 
	0x00, 0x00, 0x41, 0x7F, 0x00, // ]
	0x04, 0x02, 0x01, 0x02, 0x04, // ^
	0x40, 0x40, 0x40, 0x40, 0x40, // _
	0x00, 0x01, 0x02, 0x04, 0x00, // `
	0x20, 0x54, 0x54, 0x54, 0x78, // a
	0x7F, 0x44, 0x44, 0x44, 0x38, // b
	0x38, 0x44, 0x44, 0x44, 0x44, // c
	0x38, 0x44, 0x44, 0x44, 0x7F, // d
	0x38, 0x54, 0x54, 0x54, 0x18, // e
	0x04, 0x04, 0x7E, 0x05, 0x05, // f
	0x08, 0x54, 0x54, 0x54, 0x3C, // g
	0x7F, 0x08, 0x04, 0x04, 0x78, // h
	0x00, 0x44, 0x7D, 0x40, 0x00, // i
	0x20, 0x40, 0x44, 0x3D, 0x00, // j
	0x7F, 0x10, 0x28, 0x44, 0x00, // k
	0x00, 0x41, 0x7F, 0x40, 0x00, // l
	0x7C, 0x04, 0x78, 0x04, 0x78, // m
	0x7C, 0x08, 0x04, 0x04, 0x78, // n
	0x38, 0x44, 0x44, 0x44, 0x38, // o
	0x7C, 0x14, 0x14, 0x14, 0x08, // p
	0x08, 0x14, 0x14, 0x14, 0x7C, // q
	0x00, 0x7C, 0x08, 0x04, 0x04, // r
	0x48, 0x54, 0x54, 0x54, 0x20, // s
	0x04, 0x04, 0x3F, 0x44, 0x44, // t
	0x3C, 0x40, 0x40, 0x20, 0x7C, // u
	0x1C, 0x20, 0x40, 0x20, 0x1C, // v
	0x3C, 0x40, 0x30, 0x40, 0x3C, // w
	0x44, 0x28, 0x10, 0x28, 0x44, // x
	0x0C, 0x50, 0x50, 0x50, 0x3C, // y
	0x44, 0x64, 0x54, 0x4C, 0x44, // z
	0x00, 0x08, 0x36, 0x41, 0x41, // {
	0x00, 0x00, 0x7F, 0x00, 0x00, // |
	0x41, 0x41, 0x36, 0x08, 0x00, // }
0x02, 0x01, 0x02, 0x04, 0x02};// ~




// Purpose:       Draw a line on a graphic LCD using Bresenham's
//                line drawing algorithm
// Inputs:        (x1, y1) - the start coordinate
//                (x2, y2) - the end coordinate
//                colour - ON or OFF
// Dependencies:  glcd_pixel()
void glcd_line(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, bool colour)
{
	int8_t  x, y, addx, addy, dx, dy;
	int16_t P;
	uint8_t i;
	dx = abs((int8_t)(x2 - x1));
	dy = abs((int8_t)(y2 - y1));
	x = x1;
	y = y1;

	if(x1 > x2)
	addx = -1;
	else
	addx = 1;
	if(y1 > y2)
	addy = -1;
	else
	addy = 1;

	if(dx >= dy)
	{
		P = 2*dy - dx;

		for(i=0; i<=dx; ++i)
		{
			glcd_pixel(x, y, colour);

			if(P < 0)
			{
				P += 2*dy;
				x += addx;
			}
			else
			{
				P += 2*dy - 2*dx;
				x += addx;
				y += addy;
			}
		}
	}
	else
	{
		P = 2*dx - dy;

		for(i=0; i<=dy; ++i)
		{
			glcd_pixel(x, y, colour);

			if(P < 0)
			{
				P += 2*dx;
				y += addy;
			}
			else
			{
				P += 2*dx - 2*dy;
				x += addx;
				y += addy;
			}
		}
	}
}


// Purpose:       Draw a rectangle on a graphic LCD
// Inputs:        (x1, y1) - the start coordinate
//                (x2, y2) - the end coordinate
//                fill  - YES or NO
//                colour - ON or OFF
// Dependencies:  glcd_pixel(), glcd_line()
void glcd_rect(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, bool fill, bool colour)
{
	if(fill)
	{
		uint8_t y, ymax;                          // Find the y min and max
		if(y1 < y2)
		{
			y = y1;
			ymax = y2;
		}
		else
		{
			y = y2;
			ymax = y1;
		}

		for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle
		glcd_line(x1, y, x2, y, colour);
	}
	else
	{
		glcd_line(x1, y1, x2, y1, colour);      // Draw the 4 sides
		glcd_line(x1, y2, x2, y2, colour);
		glcd_line(x1, y1, x1, y2, colour);
		glcd_line(x2, y1, x2, y2, colour);
	}
}


// Purpose:       Draw a bar (wide line) on a graphic LCD
// Inputs:        (x1, y1) - the start coordinate
//                (x2, y2) - the end coordinate
//                width  - The number of pixels wide
//                colour - ON or OFF
void glcd_bar(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t width, bool colour)
{
	int8_t  x, y, addx, addy, j;
	int16_t P, dx, dy, c1, c2;
	uint8_t i;
	dx = abs((int8_t)(x2 - x1));
	dy = abs((int8_t)(y2 - y1));
	x = x1;
	y = y1;
	c1 = -dx*x1 - dy*y1;
	c2 = -dx*x2 - dy*y2;

	if(x1 > x2)
	{
		addx = -1;
		c1 = -dx*x2 - dy*y2;
		c2 = -dx*x1 - dy*y1;
	}
	else
	addx = 1;
	if(y1 > y2)
	{
		addy = -1;
		c1 = -dx*x2 - dy*y2;
		c2 = -dx*x1 - dy*y1;
	}
	else
	addy = 1;

	if(dx >= dy)
	{
		P = 2*dy - dx;

		for(i=0; i<=dx; ++i)
		{
			for(j=-(width/2); j<width/2+width%2; ++j)
			{
				if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0)
				glcd_pixel(x, y+j, colour);
			}
			if(P < 0)
			{
				P += 2*dy;
				x += addx;
			}
			else
			{
				P += 2*dy - 2*dx;
				x += addx;
				y += addy;
			}
		}
	}
	else
	{
		P = 2*dx - dy;

		for(i=0; i<=dy; ++i)
		{
			if(P < 0)
			{
				P += 2*dx;
				y += addy;
			}
			else
			{
				P += 2*dx - 2*dy;
				x += addx;
				y += addy;
			}
			for(j=-(width/2); j<width/2+width%2; ++j)
			{
				if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0)
				glcd_pixel(x+j, y, colour);
			}
		}
	}
}


// Purpose:       Draw a circle on a graphic LCD
// Inputs:        (x,y) - the center of the circle
//                radius - the radius of the circle
//                fill - YES or NO
//                colour - ON or OFF
void glcd_circle(uint8_t x, uint8_t y, uint8_t radius, bool fill, bool colour)
{
	int8_t a, b, P;
	a = 0;
	b = radius;
	P = 1 - radius;

	do
	{
		if(fill)
		{
			glcd_line(x-a, y+b, x+a, y+b, colour);
			glcd_line(x-a, y-b, x+a, y-b, colour);
			glcd_line(x-b, y+a, x+b, y+a, colour);
			glcd_line(x-b, y-a, x+b, y-a, colour);
		}
		else
		{
			glcd_pixel(a+x, b+y, colour);
			glcd_pixel(b+x, a+y, colour);
			glcd_pixel(x-a, b+y, colour);
			glcd_pixel(x-b, a+y, colour);
			glcd_pixel(b+x, y-a, colour);
			glcd_pixel(a+x, y-b, colour);
			glcd_pixel(x-a, y-b, colour);
			glcd_pixel(x-b, y-a, colour);
		}

		if(P < 0)
		P+= 3 + 2*a++;
		else
		P+= 5 + 2*(a++ - b--);
	} while(a <= b);
}


// Purpose:       Write a char on a graphic LCD using the 3x6 bit font
void glcd_putc36(char c)
{
	uint8_t j, k, l, m;                     // Loop counters
	uint8_t pixelData[3];                     // Stores character data
	
	if(c == '\r') { glcd_x = 0; return; }
	if(c == '\n') { glcd_y += 7 * glcd_size; return; }

	if(c < 0x20 || c > 0x60) // Checks if the letter is in the first text array
	memcpy(pixelData, TEXT_3x6_1[0], 3);   // Default to space
	else
	memcpy(pixelData, TEXT_3x6_1[c-' '], 3);
	
	for(j=0; j<3; ++j, glcd_x+=glcd_size) {        // Loop through character uint8_t data
		for(k=2; k<8*glcd_size; ++k) {         // Loop through the vertical pixels
			if(bit_test(pixelData[j], k)) {// Check if the pixel should be set
				for(l=0; l<glcd_size; ++l) {     // The next two loops change the
					for(m=0; m<glcd_size; ++m){
						glcd_pixel(glcd_x+m, glcd_y+k*glcd_size+l, glcd_colour); // Draws the pixel
					}
				}
			}
		}
	}
	glcd_x += glcd_size;
}



// Purpose:       Write text string in 3x6 font on a graphic LCD
void glcd_text36(char* textptr)
{
	for(; *textptr != '\0'; ++textptr)                  // Loop through the passed string
	glcd_putc36(*textptr);
}




// Purpose:       Write a char on a graphic LCD using the 5x7 bit font
// Inputs:        (x,y) - The upper left coordinate of the first letter
//                textptr - A pointer to an array of text to display
//                size - The size of the text: 1 = 5x7, 2 = 10x14, ...
//                colour - ON or OFF
void glcd_putc57(char c)
{
	uint8_t j, k, l, m;                     // Loop counters
	uint8_t pixelData[5];                     // Stores character data
	
	if(c == '\r') { glcd_x = 0; return; }
	if(c == '\n') { glcd_y += 8 * glcd_size; return; }

	if(c < 'S') // Checks if the letter is in the first text array
	memcpy(pixelData, TEXT_5x7_1[c-' '], 5);
	else if(c <= '~') // Check if the letter is in the second array
	memcpy(pixelData, TEXT_5x7_2[c-'S'], 5);
	else
	memcpy(pixelData, TEXT_5x7_1[0], 5);   // Default to space
	
	for(j=0; j<5; ++j, glcd_x+=glcd_size) {        // Loop through character uint8_t data
		for(k=0; k<7*glcd_size; ++k) {         // Loop through the vertical pixels
			if(bit_test(pixelData[j], k)) {// Check if the pixel should be set
				for(l=0; l<glcd_size; ++l) {     // The next two loops change the character's size
					for(m=0; m<glcd_size; ++m) {
						glcd_pixel(glcd_x+m, glcd_y+k*glcd_size+l, glcd_colour); // Draws the pixel
					}
				}
			}
		}
	}
	glcd_x += glcd_size;
}



// Purpose:       Write text string in 5x7 font on a graphic LCD
void glcd_text57(char* textptr)
{
	for(; *textptr != '\0'; ++textptr)                  // Loop through the passed string
	glcd_putc57(*textptr);
}

